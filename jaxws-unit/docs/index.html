
<html xmlns:d="jelly:define" xmlns:jsl="jelly:jsl" xmlns:j="jelly:core" xmlns:l="layout" xmlns:x="jelly:xml">
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=iso-8859-1"> 
    <title>JAX-WS/Tango Test Harness User Guide</title> 
    <style>
		H1 {
			text-align: center;
		}
		
		PRE.cmd { /* command line example */
			background-color: #eee;
			border: solid 1px gray;
			font-weight: bold;
			padding: 0.2em;
		}
		
		PRE.script { /* script example */
			background-color: #efe;
			border: solid 1px darkgreen;
			font-weight: bold;
			padding: 0.2em;
		}
		
		PRE.dir { /* directory layout */
			padding: 0.2em;
			align: center;
		}
		
		DIV.tip {
			padding: 0.2em;
			margin: 1em;
			margin-left: 3em;
			border: 1px dashed black;
			background-color: #ddf;
		}
	</style> 
  </head> 
  <body>         
    <h1>JAX-WS/Tango Test Harness User Guide</h1> 
    <div align="right">$Id: index.html,v 1.2 2006-10-02 22:06:25 vivekp Exp $</div>      
    <h2>Table of contents</h2> 
    <ol>             
      <li>
        <a href="#Running_Tests">Running Tests</a>
      </li> 
      <ol>   
        <li>
          <a href="#Configuring_the_Harness_Classpath_for_Different_Delivery_Vehicles">Configuring the Harness Classpath for Different Delivery Vehicles</a>
        </li> 
        <ol>   
          <li>
            <a href="#JAX_WS_RI_Workspace">JAX-WS RI Workspace</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#JAX_WS_RI_Binary_Image">JAX-WS RI Binary Image</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#WSIT_Workspace">WSIT Workspace</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#WSIT_Binary_Image">WSIT Binary Image</a>
          </li> 
          <ol> </ol>  
        </ol>    
        <li>
          <a href="#Running_Tests_Manually">Running Tests Manually</a>
        </li> 
        <ol> </ol>    
        <li>
          <a href="#Debugging_Test_Failures">Debugging Test Failures</a>
        </li> 
        <ol>   
          <li>
            <a href="#Looking_Inside_Working_Directory">Looking Inside Working Directory</a>
          </li> 
          <ol> </ol>  
        </ol>    
        <li>
          <a href="#Testing_Different_Transports_Containers">Testing Different Transports/Containers</a>
        </li> 
        <ol>   
          <li>
            <a href="#Local__No_Container_">Local (No Container)</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#Tomcat">Tomcat</a>
          </li> 
          <ol>   
            <li>
              <a href="#Embedded_Tomcat">Embedded Tomcat</a>
            </li> 
            <ol> </ol>    
            <li>
              <a href="#Remote_Tomcat">Remote Tomcat</a>
            </li> 
            <ol> </ol>    
            <li>
              <a href="#Local_Tomcat">Local Tomcat</a>
            </li> 
            <ol> </ol>  
          </ol>    
          <li>
            <a href="#Glassfish">Glassfish</a>
          </li> 
          <ol>   
            <li>
              <a href="#Remote_Glassfish">Remote Glassfish</a>
            </li> 
            <ol> </ol>    
            <li>
              <a href="#Local_Glassfish">Local Glassfish</a>
            </li> 
            <ol> </ol>  
          </ol>  
        </ol>    
        <li>
          <a href="#Running_Batch_Tests">Running Batch Tests</a>
        </li> 
        <ol> </ol>    
        <li>
          <a href="#Summarizing_Test_Results">Summarizing Test Results</a>
        </li> 
        <ol> </ol>  
      </ol>                
      <li>
        <a href="#Writing_Tests">Writing Tests</a>
      </li> 
      <ol>   
        <li>
          <a href="#Conventions">Conventions</a>
        </li> 
        <ol> </ol>    
        <li>
          <a href="#Test_Descriptor">Test Descriptor</a>
        </li> 
        <ol> </ol>    
        <li>
          <a href="#Client_Test_Scripts">Client Test Scripts</a>
        </li> 
        <ol>   
          <li>
            <a href="#Invoking_Services">Invoking Services</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#More_on_Script_Execution_Environment">More on Script Execution Environment</a>
          </li> 
          <ol> </ol>  
        </ol>    
        <li>
          <a href="#Service">Service</a>
        </li> 
        <ol>   
          <li>
            <a href="#WSDL">WSDL</a>
          </li> 
          <ol> </ol>  
        </ol>    
        <li>
          <a href="#Resources">Resources</a>
        </li> 
        <ol> </ol>  
      </ol>                
      <li>
        <a href="#Technical_Assistance">Technical Assistance</a>
      </li> 
      <ol> </ol>        
    </ol>          
    <a name="Running_Tests"></a>
    <h2>
      <a name="Running_Tests">
        <a href="#Running_Tests">1.</a>  Running Tests
      </a>
    </h2>           
    <a name="Configuring_the_Harness_Classpath_for_Different_Delivery_Vehicles"></a>
    <h3>
      <a name="Configuring_the_Harness_Classpath_for_Different_Delivery_Vehicles">
        <a href="#Configuring_the_Harness_Classpath_for_Different_Delivery_Vehicles">1.1.</a>  Configuring the Harness Classpath for Different Delivery Vehicles
      </a>
    </h3>   
    <p>The harness can be used to test different projects that use the JAX-WS RI.         
    <a name="JAX_WS_RI_Workspace"></a>
    <h4>
      <a name="JAX_WS_RI_Workspace">
        <a href="#JAX_WS_RI_Workspace">1.1.1.</a>  JAX-WS RI Workspace
      </a>
    </h4>   
    <p>The following option tells the harness to pick up the JAX-WS RI classes from the JAX-WS workspace. Specifically, with this option, the harness will look into various
      <tt>build/classes</tt> and library jars.
      
    <pre class="cmd">$ java -jar path/to/harness.jar -cp:jaxws path/to/jaxws-ri-workspace test-dir1 test-dir2 ...</pre>               
    <a name="JAX_WS_RI_Binary_Image"></a>
    <h4>
      <a name="JAX_WS_RI_Binary_Image">
        <a href="#JAX_WS_RI_Binary_Image">1.1.2.</a>  JAX-WS RI Binary Image
      </a>
    </h4>   
    <p>The following option tells the harness to pick up the RI classes from a JAX-WS binary dist image. Using this option, the harness will only look at the RI library jars found under the
      <TT>lib</TT> directory of the top-level dist image directory that you specify.
      
    <pre class="cmd">$ java -jar path/to/harness.jar -cp:jaxws-image path/to/jaxws-ri-image test-dir1 test-dir2 ...</pre>               
    <a name="WSIT_Workspace"></a>
    <h4>
      <a name="WSIT_Workspace">
        <a href="#WSIT_Workspace">1.1.3.</a>  WSIT Workspace
      </a>
    </h4>   
    <p>The following option tells the harness to pick up the WSIT classes from a WSIT workspace. Specifically, with this option, the harness will look into various
      <tt>build/classes</tt> and library jars.
      
    <pre class="cmd">$ java -jar path/to/harness.jar <span style="color:red; font-weight:bold">-cp:wsit path/to/wsit-workspace</span> test-dir1 test-dir2 ...</pre>               
    <a name="WSIT_Binary_Image"></a>
    <h4>
      <a name="WSIT_Binary_Image">
        <a href="#WSIT_Binary_Image">1.1.4.</a>  WSIT Binary Image
      </a>
    </h4>   
    <p>The following option tells the harness to pick up the WSIT classes from a binary dist image. Using this option, the harness will only look at the WSIT library jars (webservices.jar &amp; webservices-tools.jar) found under the
      <TT>lib</TT> directory of the dist image directory that you specify.
      
    <pre class="cmd">$ java -jar path/to/harness.jar -cp:wsit-image path/to/wsit-image test-dir1 test-dir2 ...</pre>                    
    <a name="Running_Tests_Manually"></a>
    <h3>
      <a name="Running_Tests_Manually">
        <a href="#Running_Tests_Manually">1.2.</a>  Running Tests Manually
      </a>
    </h3>   
    <p>Each test is packaged in a directory. The following command runs a single test stored in
      <tt>testdata/abc/def</tt>:
      
    <pre class="cmd">$ java -jar path/to/harness.jar testdata/abc/def</pre>  
    <p>If you specify multiple directories, all the tests in the specified directories are run.  
    <pre class="cmd">$ java -jar path/to/harness.jar testdata/abc/*</pre>  
    <p>The
      <tt>-r</tt> option tells the harness to recursively search for all tests inside the given directory:
      
    <pre class="cmd">$ java -jar path/to/harness.jar -r testdata/addressing</pre>   
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> Consider defining an alias to
            <tt>java -jar path/to/harness.jar</tt> or a wrapper shell script so that you don't have to type the path name manually. 
          </td> 
        </tr>
      </table> 
    </div>               
    <a name="Debugging_Test_Failures"></a>
    <h3>
      <a name="Debugging_Test_Failures">
        <a href="#Debugging_Test_Failures">1.3.</a>  Debugging Test Failures
      </a>
    </h3>   
    <p>The following command executes a test with debugger support enabled. Run this command from a console, then set up a remote debugging with your IDE to port 8000. This allows you to set breakpoints anywhere both on the client and the server.  
    <pre class="cmd">$ java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000 -jar path/to/harness.jar testdata/abc/def</pre>   
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> You'll use this command very often, so consider defining an alias to
            <tt>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000 -jar path/to/harness.jar</tt>  
          </td> 
        </tr>
      </table> 
    </div>  
    <p>If your test data resides in the Tango workspace or the JAX-WS workspace, the harness recognizes their directory layouts and pick up classes from respective
      <tt>build/class</tt> directories and libraries. So if you make a change to the source code, all you need to do is to compile them to class files.
      
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> Do not run any targets that generate jar files, as those unnecessary work will slow you down. </td> 
        </tr>
      </table> 
    </div>  
    <p>If your change to the code is to the runtime and does not affect the code generation, then use the
      <tt>-skip</tt> option to skip the code generation. This allows you to quickly rerun the runtime portion of the tests without wasting time running all the tools just to produce the same results.
      
    <pre class="cmd">$ java -jar path/to/harness.jar -skip testdata/abc/def</pre>          
    <a name="Looking_Inside_Working_Directory"></a>
    <h4>
      <a name="Looking_Inside_Working_Directory">
        <a href="#Looking_Inside_Working_Directory">1.3.1.</a>  Looking Inside Working Directory
      </a>
    </h4>   
    <p>The test harness leaves all the artifacts generated during a test execution inside a working directory called
      <tt>work</tt> in each test directory. Sometimes inspecting what's generated becomes important, so this is the directory structure of the work directory:
      <pre class="dir">
work/                    (root test directory)
 +- client-source/       (client Java artifacts generated by wsimport from service WSDL)
 +- client-classes/      (compiled client Java artifacts. Generated from client-source by Javac)
 +- services
     +- &lt;serviceName&gt;    (this intermediate directory is only if you have multiple services)
         +- war          (root of the exploded war file image that's deployed to the server)
         +- gen-src      (generated server Java artifacts by wsimport)
</pre> 
    
    <p>Unless the
      <tt>-skip</tt> option is used, the work directory is
      <tt>"rm -rf"</tt>ed before a test execution. There's no need to manually remove them.
                      
    <a name="Testing_Different_Transports_Containers"></a>
    <h3>
      <a name="Testing_Different_Transports_Containers">
        <a href="#Testing_Different_Transports_Containers">1.4.</a>  Testing Different Transports/Containers
      </a>
    </h3>   
    <p>The harness can run tests by using a variety of transports and containers.         
    <a name="Local__No_Container_"></a>
    <h4>
      <a name="Local__No_Container_">
        <a href="#Local__No_Container_">1.4.1.</a>  Local (No Container)
      </a>
    </h4>   
    <p>By default, the test harness uses the local transport. There's no additional option required for this mode. This is the preferred mode of testing because of its quick turn-around time. This mode also allows you to use a single debug session to debug both the client and the server side. 
    <p>Some delivery vehicles (notably the distribution images) do not have the code needed to use the local transport. To test those, find the matching
      <tt>jaxws-local-transport.jar</tt> and use the
      <tt>-transport</tt> option to specify it.
      
    <pre class="cmd">$ java -jar path/to/harness.jar -cp:wsit-image path/to/wsit -transport path/to/jaxws-local-transport.jar ...</pre>               
    <a name="Tomcat"></a>
    <h4>
      <a name="Tomcat">
        <a href="#Tomcat">1.4.2.</a>  Tomcat
      </a>
    </h4>   
    <p>This test harness supports Tomcat 5.0.x or 5.5.x. There are a few different ways of using Tomcat.         
    <a name="Embedded_Tomcat"></a>
    <h5>
      <a name="Embedded_Tomcat">
        <a href="#Embedded_Tomcat">1.4.2.1.</a>  Embedded Tomcat
      </a>
    </h5>   
    <p>The following command causes the harness to run Tomcat within the same VM. This mode is bit like the local transport, in the sense that both the server and the client runs inside the same VM, but this mode run tests by using HTTP and full servlet container.  
    <pre class="cmd">$ java -jar path/to/harness.jar -tomcat-embedded path/to/tomcat test-dir1 test-dir2 ...</pre>  
    <p>
      <tt>path/to/tomcat</tt> should point to the directory where you have Tomcat installed. The harness will load Tomcat jar files from there.
    
    <p>This mode is preferrable mode of testing for Tomcat, as this provides the quickest turn-around time, and worry-free. This mode is the only mode in Tomcat where you can use a single debug session to debug both the client and the server.              
    <a name="Remote_Tomcat"></a>
    <h5>
      <a name="Remote_Tomcat">
        <a href="#Remote_Tomcat">1.4.2.2.</a>  Remote Tomcat
      </a>
    </h5>   
    <p>The following command causes tests to run by using Tomcat launched externally. The parameter to the -tomcat-remote option is
      <tt>
        <i>adminUserName</i>:
        <i>adminPassword</i>@
        <i>hostname</i>:
        <i>port</i>
      </tt>.
      
    <pre class="cmd">$ java -jar path/to/harness.jar -tomcat-remote admin:admin@localhost:8080 test-dir1 test-dir2 ...</pre>  
    <p>It is your responsibility to launch Tomcat. In this mode, the harness will only deploy and undeploy services from this running instance. The tomcat used for this purpose should
      <b>NOT</b> have JAX-WS/Tango binaries installed in
      <tt>common/lib</tt> or anywhere else. The harness will include everything necessary into a war file, and this is the only way to make sure that you are testing the bits that you are supposed to be testing.
      
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> To find out the admin username and password, look at
            <tt>$TOMCAT_HOME/conf/tomcat-users.xml</tt> and find the entry that has "manager" as one of the roles. If none is found, simply add the following two lines to the file:
            <pre>
&lt;role rolename="manager"/&gt;
&lt;user username="admin" password="admin" roles="manager"/&gt;
</pre>  
          </td> 
        </tr>
      </table> 
    </div>   
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> To debug the server side in this set up, you need to launch Tomcat with the debugger support enabled. Run
            <tt>catalina.sh jpda run</tt> to do this, and you can attach your debugger to Tomcat remotely. 
          </td> 
        </tr>
      </table> 
    </div>   
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> (Tomcat 5.0.x only) By default, Tomcat is configured to output logs to multiple places, including files in the
            <tt>logs</tt> directory and stdout/stderr. This is often inconvenient for debugging, as you are not sure which file you should monitor. You can modify
            <tt>$TOMCAT_HOME/conf/server.xml</tt> to avoid this problem, by sending all the outputs to stdout. To do so, find all "&lt;Logger&gt;" elements in server.xml and replace them with
            <tt>SystemOutLogger</tt>, like this:
            <pre>&lt;Logger className="org.apache.catalina.logger.SystemOutLogger" /&gt;</pre>  
          </td> 
        </tr>
      </table> 
    </div>   
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> When tests are aborted via Ctrl+C, web applications may be left running on this remote machine. When the test is run next time, they will be removed (or you can remove them manually.) </td> 
        </tr>
      </table> 
    </div>               
    <a name="Local_Tomcat"></a>
    <h5>
      <a name="Local_Tomcat">
        <a href="#Local_Tomcat">1.4.2.3.</a>  Local Tomcat
      </a>
    </h5>   
    <p>Run the following command to use Tomcat in the local mode. In this mode, the haress launches Tomcat as a child process, run tests, and terminates Tomcat when everything is done.  
    <pre class="cmd">$ java -jar path/to/harness.jar -tomcat-local path/to/tomcat test-dir1 test-dir2 ...</pre>  
    <p>See the tips for the remote tomcat support for how to configure Tomcat to report logs to one place.  
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> On Windows systems, aborting the harness via Ctrl+C will leave the child Tomcat process running (does anyone know how to fix that?) Those orphan processes can be killed from task manager (be careful not to kill other Java processes), or better yet,
            <a href="http://www.sysinternals.com/Utilities/ProcessExplorer.html">process explorer</a>. 
          </td> 
        </tr>
      </table> 
    </div>                    
    <a name="Glassfish"></a>
    <h4>
      <a name="Glassfish">
        <a href="#Glassfish">1.4.3.</a>  Glassfish
      </a>
    </h4>   
    <p>This test harness supports Glassfish 1.0.         
    <a name="Remote_Glassfish"></a>
    <h5>
      <a name="Remote_Glassfish">
        <a href="#Remote_Glassfish">1.4.3.1.</a>  Remote Glassfish
      </a>
    </h5>   
    <p>To test with existing instance of Glassfish, use the following option. This mode assumes that you have already started a domain, and the harness will simply deploy/undeploy applications to this running service:  
    <pre class="cmd">$ java -jar path/to/harness.jar -glassfish-remote localhost test-dir1 test-dir2 ...</pre>  
    <p>The "-glassfish-remote" takes the connection string as the parameter. The full syntax of the paramter is
      <tt>[USER:PASS@]HOST[:PORT][-HTTPURL]</tt>. The first four parts up to '-' specifies the Glassfish admin port. USER and PASS is used for the administrator login, and PORT is the admin TCP port. The last HTTPURL specifies the URL with which client test programs talk to the service. All components but HOST are defaulted, so if your glassfish installation is out of the box, then all you need to specify is the host name where Glassfish runs.
      
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> Glassfish has its copy of JAX-WS, so testing with Glassfish requires us to replace the runtime of Glassfish. At this point the harness is not capable of doing that. </td> 
        </tr>
      </table> 
    </div>               
    <a name="Local_Glassfish"></a>
    <h5>
      <a name="Local_Glassfish">
        <a href="#Local_Glassfish">1.4.3.2.</a>  Local Glassfish
      </a>
    </h5>   
    <p>The test harness is capable of starting and stopping Glassfish on its own before/after running tests. This mode assumes that you have Glassfish installed locally. Use the following command line option to run in this mode:  
    <pre class="cmd">$ java -jar path/to/harness.jar -glassfish-local path/to/glassfish test-dir1 test-dir2 ...</pre>  
    <p>The harness will create a domain configuration in a temporary directory and run tests from there, so this running mode will not touch the files in
      <tt>path/to/glassfish</tt> --- it is simply used to load jar files. All the TCP ports are chosen randomly from 20000-50000 ranges, to avoid collisions with other tests that happen to be running on the same machine. See the console output for the HTTP port and admin port, in case you need to manually access them for debugging. The admin user name and password will be set to "admin" and "adminadmin" respectively.
    
    <p>This mode is convenient for fully automated Glassfish testing, because you do not need a dedicated Glassfish installation per each test set up, and the harness chooses the right TCP ports to avoid conflicts. However, starting and stopping Glassfish takes significant amount of time, so it's almost impossible to use for interactive debugging.                        
    <a name="Running_Batch_Tests"></a>
    <h3>
      <a name="Running_Batch_Tests">
        <a href="#Running_Batch_Tests">1.5.</a>  Running Batch Tests
      </a>
    </h3>   
    <p>There are a few command-line options that often go with automated batch test for a large number of tests. First, use
      <tt>-p N</tt> to run tests by using N number of threads. This should be used on a multi-processor system to reduce the turn-around time of the test, and therefore ideal for continuous testing.
                 
    <a name="Summarizing_Test_Results"></a>
    <h3>
      <a name="Summarizing_Test_Results">
        <a href="#Summarizing_Test_Results">1.6.</a>  Summarizing Test Results
      </a>
    </h3>   
    <p>The
      <tt>-report DIR</tt> option causes the harness to generate JUnit test report files into the specified directory. This allows the reports to be combined with other JUnit or TestNG-based tests (such as per-class unit test.) These XML reports can be then formatted into HTML (via &lt;junitreport&gt; ant task) or picked up by Hudson for further processing.
                      
    <a name="Writing_Tests"></a>
    <h2>
      <a name="Writing_Tests">
        <a href="#Writing_Tests">2.</a>  Writing Tests
      </a>
    </h2>           
    <a name="Conventions"></a>
    <h3>
      <a name="Conventions">
        <a href="#Conventions">2.1.</a>  Conventions
      </a>
    </h3>   A single end-to-end test consists of a client talking to services. Each test is organized into one directory. A test directory could look like the following:
    <pre class="dir">
testdir/
 +- test-descriptor.xml     (metadata file that describes a test)
 +- *.bsh                   (client test scripts)
 +- resources/              (resource files if needed by test)
 |   +- mascot.jpeg
 |
 +- AddNumbers.wsdl         (WSDL that represents service, if any)
 +- **/*.java               (Java code that implements service)
</pre>              
    <a name="Test_Descriptor"></a>
    <h3>
      <a name="Test_Descriptor">
        <a href="#Test_Descriptor">2.2.</a>  Test Descriptor
      </a>
    </h3>   
    <p>The file
      <TT>test-descriptor.xml</TT> is the heart of the test data, and it contains the required configuration information for each test. A typical "fromwsdl" test descriptor could look like the following:
      <br> 
      <pre>
&lt;descriptor&gt;
   &lt;description&gt;this is a very useful test that tests stuff&lt;/description&gt; 
   &lt;client href="*.bsh"/&gt;
   &lt;service&gt;
     &lt;wsdl href="AddNumbers.wsdl"/&gt;
   &lt;/service&gt;
&lt;/despcriptor&gt;
</pre> 
    
    <p>The structure of the test descriptor is defined in
      <a href="test-descriptor.rnc">a schema</a>, and the harness performs an XML validation to make sure the data is in the expected format.
                 
    <a name="Client_Test_Scripts"></a>
    <h3>
      <a name="Client_Test_Scripts">
        <a href="#Client_Test_Scripts">2.3.</a>  Client Test Scripts
      </a>
    </h3>   
    <p>Client test scripts are the programs that are executed after all the services are set up. These scripts are expected to make some service invocations and perform assretions. Test scripts can be written as:
      <ul>
        <li>files. They can be anywhere and have any name, since the harness locates them through
          <tt>&lt;client href="..."&gt;</tt> inside the descriptor. However, we recommend keeping them at the top directory and use ".bsh" suffix.
        </li>
        <li>Inline inside the test descriptor, as illustrated below. This is particularly convenient for small test clients:
          <pre>
&lt;descriptor&gt;
  &lt;description&gt;this is a very useful test that tests stuff&lt;/description&gt; 
  &lt;client&gt;
    assertEquals("hello",fooPort.echo("hello"));
  &lt;/client&gt;
  ...
&lt;/descriptor&gt;
</pre> 
        </li>
      </ul> 
    
    <p>Scripts are written in the
      <a href="http://www.beanshell.org">Beanshell</a> scripting language. BeanShell is mostly compatible with Java, so you can write any valid Java programs, such as:
      
    <pre class="script">
import java.math.*;
BigInteger bi = new BigInteger("35.12");
</pre>  
    <p>As a scripting language, BeanShell allows you to save typing. Specifically,
      <ol>
        <li>You need not perform any explicit casting, since variables are not statically typed.</li>
        <li>No explicit variable declaration is required (although allowed)</li>
        <li>Auto-boxing/unboxing ala Tiger</li>
        <li>Type parameters are not needed (in fact they are not supported)</li>
      </ol> 
    
    <p>So you can write a program like this: 
      <pre class="script">
import java.math.*;
bi = new Holder(new BigInteger("35.12")); // create JAX-WS holder object with BigInteger
</pre>  
    
    <p>See
      <a href="http://www.beanshell.org/manual/syntax.html">beanshell syntax documentation</a> for more about BeanShell syntax.
             
    <a name="Invoking_Services"></a>
    <h4>
      <a name="Invoking_Services">
        <a href="#Invoking_Services">2.3.1.</a>  Invoking Services
      </a>
    </h4>   
    <p>To isolate the tests from the environment, and to make tests as reusable as possible, the harness creates services and port objects on behalf of the test programs. This allows the harness to configure ports correctly, so that they can talk to the right service.
    <p>For this reason, it's important for the client program now to create port objects on its own. See the following illustration: 
      <pre class="script">
// :-&lt; BAD EXAMPLE
port = new HelloService().getHelloPort();
port.sayHelloTo("duke");

// :-) GOOD EXAMPLE
helloPort.sayHelloTo("duke");
</pre>  
    
    <p>To find out what port variables are imported under what names, check the output from the test harness. Right before the client script executes, you should see a line like this:
      <pre>injected ports: addNumbersPort</pre> 
    
    <p>The only exception to this "don't create your ports" rule is when you need
      <tt>Dispatch</tt> objects, where you'd need to use the pre-defined variable "endpointAddress" 
      <span style="color:red; font-weight:bold">(not fully cooked. Feedback welcome)</span>  : 
      <pre class="script">
// create dispatch
svc = new HelloService();
svc.addPort(new QName("foo","bar"), javax.xml.ws.soap.SOAPBinding.SOAP11HTTP_BINDING, endpointAddress);
</pre>  
                 
    <a name="More_on_Script_Execution_Environment"></a>
    <h4>
      <a name="More_on_Script_Execution_Environment">
        <a href="#More_on_Script_Execution_Environment">2.3.2.</a>  More on Script Execution Environment
      </a>
    </h4>   
    <p>For productivity, scripts are run in a configured environment. Client scripts are expected to take advantage of those.
      <ol>
        <li>Script can invoke any of the
          <a href="http://www.junit.org/junit/javadoc/3.8.1/junit/framework/Assert.html">
            <tt>junit.framework.Assert</tt>
          </a> methods without any qualifier. So you can just write
          <tt>assertEquals(5,3+2)</tt>. This is the prefered way of testing assertions.
        </li>
        <li>The following Java packages are implicitly imported.
          <ul>
            <li>java.lang</li>
            <li>javax.xml.ws</li>
            <li>javax.xml.bind</li>
            <li>javax.xml.namespace</li>
            <li>(client artifact packages)</li>
          </ul> So you could just say
          <tt>JAXBContext.newInstance(...)</tt> instead of
          <tt>javax.xml.bind.JAXBContext.newInstance(...)</tt>. Client artifact packages are all imported, too, so for example if you need to create a bean for service invocation, you can do as follows: 
          <pre class="script">
bean = new FooBarBean(); // instead of new test.fromwsdl.helloLit.client.FooBarBean();
bean.setName("Duke");
bean.setId(53);
</pre>  
        </li>
        <li>Helper methods. The harness defines a few helper methods that are avaialble to the script as if they are global functions. See
          <a href="http://kohsuke.sfbay/hudson/job/jaxws-test-harness/ws/src/com/sun/xml/ws/test/client/ScriptBaseClass.java">this source code</a> for the complete list and their semantics.
        </li>
      </ol> 
                      
    <a name="Service"></a>
    <h3>
      <a name="Service">
        <a href="#Service">2.4.</a>  Service
      </a>
    </h3>   
    <p>Code that constitutes a service needs to be written by using Java. By default, those files should be placed into the same test directory. If you are converting existing test services to this harness, most likely the only thing that needs to change is the declared package name.
    <p>In a rare circumstance, where you need multiple independently deployed services, you can use
      <TT>&lt;service basedir="..."/&gt;</TT> value to move service source files into subdirectories to isolate them.
      
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> To set a binding in fromjava scenarios, use the
            <tt>javax.xml.ws.BindingType</tt> annotation on your service class. For example,
            <pre>
@WebService
@BindingType(SOAPBinding.SOAP11HTTP_BINDING)
class FooBarService {
  ...
}
</pre>  
          </td> 
        </tr>
      </table> 
    </div>          
    <a name="WSDL"></a>
    <h4>
      <a name="WSDL">
        <a href="#WSDL">2.4.1.</a>  WSDL
      </a>
    </h4>   
    <p>For scenarios which requiring building the service from a WSDL, there is a sub-element of service named
      <TT>wsdl</TT> with has an attribute named
      <TT>href</TT>.
      <TT>href</TT> should name the WSDL file, relative to the service's
      <TT>basedir</TT>.
    
    <p>When present, WSDL is first complied and then the artifacts are compiled together with the rest of the Java source files. The harness uses the
      <tt>-p</tt> option of wsimport to place the generated artifacts into the "right" package (infered from the directory name of the service.)
    
    <p>To further customize the compilation process, place a JAX-WS customization file named
      <tt>custom-server.xml</tt> to the service top directory (to refer to WSDL file and schema files from this customization file, just use the relative path from the customization file to WSDL/schemas like
      <tt>"./foo.xsd"</tt>.
                      
    <a name="Resources"></a>
    <h3>
      <a name="Resources">
        <a href="#Resources">2.5.</a>  Resources
      </a>
    </h3>   
    <p>If test programs need to use image files, binary files, or other data files, they should be put in
      <TT>resources</TT> directory at test's top-level. This is optional. Those resources can be loaded by using the helper methods as follows: 
      <pre class="script">
File f = resource("foo.xml");  // load resources/foo.xml
</pre>  
    
    <p> 
      <span style="color:red; font-weight:bold">(not fully cooked. Feedback welcome)</span>  we are hoping to define more convenience methods and define how to access resources from server.
                      
    <a name="Technical_Assistance"></a>
    <h2>
      <a name="Technical_Assistance">
        <a href="#Technical_Assistance">3.</a>  Technical Assistance
      </a>
    </h2>   
    <p>Talk to Ken, Bhakti, Bobby, or Kohsuke if you have technical problems with the harness and need in-person assistance.
    <p>We use
      <a href="http://ws-test-harness.dev.java.net/">the java.net ws-test-harness project</a> for developing the harness. We use the
      <tt>dev@ws-test-harness.dev.java.net</tt> alias and the SWAN IRC
      <tt>#ws-test-harness</tt> for communication.
    
    <p>Our goal is to improve your developer productivity. Please use
      <a href="https://ws-test-harness.dev.java.net/issues/">the issue tracker</a> for keeping track of RFEs and problems.
           
  </body>
</html>